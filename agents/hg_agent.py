"""
hg_agent.py
-----------
Mercurial Version Control Agent â€” Phase 3 of the AI automation pipeline.

Responsibilities:
  1. Create a new feature branch in the SDPLIVE hg repo
  2. hg add any new .java files generated by the pipeline
  3. hg commit with a structured message
  4. hg push --new-branch to the configured remote
  5. Report the branch name + revision so the team can review & merge to default

Branch naming convention (mirrors the team's existing pattern):
  feature/AI_GEN_<FEATURE_SLUG>_BRANCH
  e.g. feature/AI_GEN_SLA_BREACH_NOTIFICATION_BRANCH

This agent is OPT-IN: it only activates when 'hg_config' is present in state.
If not set, it's a no-op â€” existing pipeline flow is unchanged.

hg_config example:
  {
    "repo_root":    "/path/to/SDPLIVE_LATEST_AUTOMATER_SELENIUM",  # default: auto-detected
    "branch_name":  "",          # if empty, auto-generated from feature_description
    "commit_msg":   "",          # if empty, auto-generated
    "push":         True,        # set False to skip push (commit locally only)
    "remote":       "default",   # hg path alias (usually "default")
  }
"""

import os
import re
import subprocess
import textwrap
from datetime import datetime
from pathlib import Path
from typing import Any

from agents.state import AgentState
from config.project_config import PROJECT_NAME, BASE_DIR as PROJECT_BASE


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _run(cmd: list[str], cwd: str, check: bool = True) -> subprocess.CompletedProcess:
    """Run an hg command, capture output, optionally raise on failure."""
    return subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        check=check,
    )


def _slugify(text: str, max_words: int = 6) -> str:
    """
    Turn a feature description into a branch-safe slug.
    'Create SLA breach notification for incident requests'
      â†’ 'CREATE_SLA_BREACH_NOTIFICATION_INCIDENT'
    """
    # Remove special chars, uppercase, split on non-word
    words = re.sub(r"[^a-zA-Z0-9\s]", " ", text).upper().split()
    # Drop common stop words
    stop = {"A", "AN", "THE", "AND", "OR", "FOR", "IN", "ON", "OF", "WITH",
            "TO", "FROM", "THAT", "IS", "ARE", "BE", "BY", "AT", "AS", "IT"}
    meaningful = [w for w in words if w not in stop and len(w) > 2][:max_words]
    return "_".join(meaningful) if meaningful else "AI_TEST"


def _detect_repo_root() -> str:
    """Auto-detect the SDPLIVE_LATEST_AUTOMATER_SELENIUM hg repo root."""
    candidate = Path(PROJECT_BASE) / PROJECT_NAME
    if candidate.exists():
        try:
            result = _run(["hg", "root"], cwd=str(candidate), check=False)
            if result.returncode == 0:
                return result.stdout.strip()
        except FileNotFoundError:
            pass
    return ""


def _hg_status(repo_root: str) -> dict[str, list[str]]:
    """
    Returns dict of file statuses keyed by hg status code:
      M = modified, A = added (staged), ? = unknown (untracked), ! = missing
    """
    result = _run(["hg", "status"], cwd=repo_root, check=False)
    status: dict[str, list[str]] = {"M": [], "A": [], "?": [], "!": [], "R": []}
    for line in result.stdout.splitlines():
        if len(line) >= 3:
            code = line[0]
            path = line[2:]
            if code in status:
                status[code].append(path)
    return status


def _filter_java_files(paths: list[str]) -> list[str]:
    """Keep only .java source files (skip .class, bin/, reports/, etc.)."""
    keep = []
    for p in paths:
        if p.endswith(".java") and not p.startswith("bin/"):
            keep.append(p)
    return keep


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# HgAgent
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HgAgent:
    """
    LangGraph node: commits generated/modified Java files to a new hg feature branch.

    Activated only when state['hg_config'] is a non-empty dict.

    Populates state['hg_result'] with:
      {
        "success":      bool,
        "branch_name":  str,
        "revision":     str,   # hg rev id after commit
        "pushed":       bool,
        "files_committed": list[str],
        "message":      str,   # human-readable summary
        "error":        str,   # populated on failure
      }
    """

    def __init__(self, base_dir: str = None):
        self.base = Path(base_dir) if base_dir else Path(__file__).resolve().parents[1]

    # â”€â”€ Public â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def run(self, state: AgentState) -> AgentState:
        """LangGraph node function."""
        hg_config = state.get("hg_config") or {}
        if not hg_config:
            state["messages"] = [
                "[HgAgent] No hg_config in state â€” skipping (opt-in only)"
            ]
            return state

        state["messages"] = [
            "[HgAgent] ðŸ”€ Starting Mercurial branch workflow..."
        ]

        try:
            result = self._commit_to_branch(state, hg_config)
            state["hg_result"] = result
            icon = "âœ…" if result["success"] else "âš ï¸"
            state["messages"] = [
                f"[HgAgent] {icon} {result['message']}"
            ]
        except Exception as exc:
            err = f"HgAgent error: {exc}"
            state["hg_result"] = {"success": False, "error": err, "message": err}
            state["errors"] = [f"[HgAgent] {err}"]
            state["messages"] = [f"[HgAgent] âŒ {err}"]

        return state

    # â”€â”€ Private â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _commit_to_branch(self, state: AgentState, cfg: dict) -> dict:
        # 1. Resolve repo root
        repo_root = cfg.get("repo_root", "").strip() or _detect_repo_root()
        if not repo_root or not Path(repo_root).exists():
            return {
                "success": False,
                "error": f"Cannot find hg repo root. Set hg_config['repo_root'] explicitly.",
                "message": "Repo root not found â€” hg workflow skipped.",
            }

        # Verify it's actually an hg repo
        check = _run(["hg", "root"], cwd=repo_root, check=False)
        if check.returncode != 0:
            return {
                "success": False,
                "error": f"'{repo_root}' is not a Mercurial repository.",
                "message": f"Not an hg repo: {repo_root}",
            }

        # 2. Determine branch name
        branch_name = cfg.get("branch_name", "").strip()
        if not branch_name:
            feature = state.get("feature_description", "")
            doc_meta = state.get("document_metadata", {})
            doc_title = doc_meta.get("document_title", "")
            source = doc_title or feature
            slug = _slugify(source)
            branch_name = f"feature/AI_GEN_{slug}_BRANCH"

        # 3. Detect what files need to be committed
        hg_stat = _hg_status(repo_root)

        # New Java files the pipeline wrote (untracked = '?')
        new_java = _filter_java_files(hg_stat["?"])
        # Modified tracked Java files
        modified_java = _filter_java_files(hg_stat["M"])

        # Also cross-reference with final_output_paths from state
        # (files may be outside the hg repo â€” skip those)
        pipeline_files = state.get("final_output_paths", [])
        in_repo = []
        for pf in pipeline_files:
            rel = None
            try:
                rel = os.path.relpath(pf, repo_root)
                # relpath goes UP (../...) â†’ outside repo
                if not rel.startswith(".."):
                    in_repo.append(rel)
            except ValueError:
                pass  # different drive on Windows

        # Combine: all modified + new java files + any pipeline files inside repo
        files_to_stage = list(dict.fromkeys(new_java + in_repo))
        files_to_commit = list(dict.fromkeys(modified_java + new_java + in_repo))

        if not files_to_commit:
            return {
                "success": True,
                "branch_name": branch_name,
                "revision": "",
                "pushed": False,
                "files_committed": [],
                "message": "No Java file changes detected in the hg repo â€” nothing to commit.",
                "error": "",
            }

        # 4. Switch to (create) the feature branch
        _run(["hg", "branch", branch_name], cwd=repo_root)

        # 5. hg add any untracked new files
        for f in files_to_stage:
            _run(["hg", "add", f], cwd=repo_root, check=False)

        # 6. Build commit message
        commit_msg = cfg.get("commit_msg", "").strip()
        if not commit_msg:
            feature_snippet = (state.get("feature_description", "") or "")[:120]
            doc_meta = state.get("document_metadata", {})
            source_label = doc_meta.get("document_title") or feature_snippet or "AI-generated tests"
            modules = ", ".join(state.get("affected_modules", [])[:4]) or "auto-detected"
            commit_msg = textwrap.dedent(f"""\
                AI-GEN: {source_label}

                Generated by AutomaterSelenium AI Test Generator
                Date    : {datetime.now().strftime('%Y-%m-%d %H:%M')}
                Modules : {modules}
                Files   : {len(files_to_commit)}
                Branch  : {branch_name}
            """).strip()

        # 7. Commit
        commit_result = _run(
            ["hg", "commit", "-m", commit_msg] + files_to_commit,
            cwd=repo_root,
            check=False,
        )
        if commit_result.returncode not in (0, 1):  # 1 = nothing changed
            err = commit_result.stderr.strip() or commit_result.stdout.strip()
            return {
                "success": False,
                "branch_name": branch_name,
                "revision": "",
                "pushed": False,
                "files_committed": files_to_commit,
                "message": f"hg commit failed: {err}",
                "error": err,
            }

        # Get revision id
        rev_result = _run(["hg", "id", "-i"], cwd=repo_root, check=False)
        revision = rev_result.stdout.strip().replace("+", "")

        # 8. Push (optional)
        pushed = False
        push_error = ""
        should_push = cfg.get("push", True)
        if should_push:
            remote = cfg.get("remote", "default")
            push_result = _run(
                ["hg", "push", "--new-branch", "-b", branch_name, remote],
                cwd=repo_root,
                check=False,
            )
            if push_result.returncode == 0:
                pushed = True
            else:
                push_error = push_result.stderr.strip() or push_result.stdout.strip()
                # returncode=1 from hg push = "no changes to push" â€” not really an error
                if "no changes found" in push_error.lower():
                    pushed = True
                    push_error = ""

        # 9. Build summary message
        push_note = (
            f"pushed to remote '{cfg.get('remote','default')}'" if pushed
            else (f"push skipped" if not should_push else f"push failed: {push_error}")
        )
        message = (
            f"Branch '{branch_name}' committed {len(files_to_commit)} file(s) "
            f"[rev {revision}] â€” {push_note}. "
            f"Merge to 'default' when ready."
        )

        return {
            "success": True,
            "branch_name": branch_name,
            "revision": revision,
            "pushed": pushed,
            "push_error": push_error,
            "files_committed": files_to_commit,
            "message": message,
            "error": "",
        }
